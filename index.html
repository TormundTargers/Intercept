<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Intercept</title>
    <script src="assets/phaser.min.js"></script>
</head>
<body>
<script>
// Global variables
var inputDirection = null;              // Stores the direction the actor is to move next
var speed = 3;                          // This is the number of pixels the actor will move each frame
var start = false;                      // If the game has started or not
var tileSize = 12;
var xTiles = 80;
var yTiles = 40;
var canvasWidth = tileSize * xTiles;
var canvasHeight = tileSize * yTiles;
// Relative grid coordinates game is played on.
var grid = new Array(xTiles);
for(var i=0;i<xTiles;i++){
    grid[i] = new Array(yTiles);
}


// Canvas size is a multiple of 32. 32x32 is the size of each grid.
var game = new Phaser.Game(canvasWidth, canvasHeight, Phaser.CANVAS, 'intercept-canvas', {
    preload: preload, create: create, update: update, render: render});
// Player
var actor;
// The trail left behind actor
var trail;

function preload() {
	// Assets that will be preloaded will go here.
    game.load.image('actor', 'assets/img/blueBike1.png');
    game.load.image('background', 'assets/img/backgroundTile12.png');
}

function create() {
    // This loads and tiles the background image
    game.add.tileSprite(0,0,canvasWidth,canvasHeight,'background');
    // Sets up the trail.
    trail = game.add.graphics(0,0);
    trail.lineStyle(3,0x3498DB,1);
    trail.boundsPadding = 0;
    //  This creates a simple sprite that is using our loaded image and
    //  displays it on-screen
    actor = game.add.sprite(canvasWidth/2, canvasHeight/2, 'actor');
    actor.anchor.x = 0.5;
    actor.anchor.y = 0.5;
    actor.scale.x = 0.3;
    actor.scale.y = 0.3;
}
function update() {
	// Updated every frame
	if (start) {
        var x = Math.floor(actor.x/tileSize);
        var y = Math.floor(actor.y/tileSize);
        getInputDirection(function(){});
		// Main game code
        if(actor.x % tileSize == 0 && actor.y % tileSize == 0) {
            if(grid[x][y]){
                start = false;
            }
            else{
                grid[x][y] = true;
                if (inputDirection != null) {
                    actor.angle = inputDirection;
                    inputDirection = null;
                }
            }
        }
        if(start) {
            switch (actor.angle) {
                case 0:
                    actor.y -= speed;
                    break;
                case 90:
                    actor.x += speed;
                    break;
                case -90:
                    actor.x -= speed;
                    break;
                case -180:
                    actor.y += speed;
                    break;
            }
            trail.lineTo(actor.x, actor.y);
            if (!outOfBounds(actor)) {
                start = false;
                //showGameOver();
            }
        }
	} else {
		getInputDirection(function() {
            start = true;
            trail.moveTo(actor.x, actor.y);
        });
	}
}
    function getInputDirection(callback) {
        if (game.input.keyboard.isDown(Phaser.Keyboard.UP) && actor.angle != -180) {
            // Start game if enter pressed.
            callback();
            inputDirection = 0;
        }
        else if (game.input.keyboard.isDown(Phaser.Keyboard.DOWN) && actor.angle != 0) {
            // Start game if enter pressed.
            callback();
            inputDirection = -180;
        }
        else if (game.input.keyboard.isDown(Phaser.Keyboard.LEFT) && actor.angle != 90) {
            // Start game if enter pressed.
            callback();
            inputDirection = -90;
        }
        else if (game.input.keyboard.isDown(Phaser.Keyboard.RIGHT) && actor.angle != -90) {
            // Start game if enter pressed.
            callback();
            inputDirection = 90;
        }
    }

    function render() {
        game.debug.spriteInfo(actor, 20, 400);

    }

    function outOfBounds(actor) {
    	return actor.x > 0 && actor.x < canvasWidth && actor.y > 0 && actor.y < canvasHeight;
    }
</script>
</body>
</html>
